Stat 523
--------

### Assignment 1: Data Structures and Subsetting

#### Explain your code where appropriate.
#### Doug Raffle (dcraffle@mix.wvu.edu)

1. Create vectors of each of the different primitive types. i.e., integer, double, logical, and character. Create matrices by attaching `dim` attributes to those vectors. Look up the help for `dimnames` and attach `dimnames` to these resulting matrices.

```{r}
## Generalize
add.dim <- function(vec){
    dim(vec) <- c(3, 3)
    dimnames(vec) <- list(paste("R", 1:3, sep = ""),
                          paste("C", 1:3, sep = ""))
    vec
}
## Integer
int.vec <- integer(9)
add.dim(int.vec)

## Double
double.vec <- numeric(9)
add.dim(double.vec)

## Logical
logical.vec <- logical(9)
add.dim(logical.vec)

## Character
char.vec <- character(9)
add.dim(char.vec)
```

2. Create a list of length 4 and then add a `dim` attribute to it. What happens?

```{r}
(foo.list <- list(A = 1:2, B = 3:4, C = 5:6, D = 7:8))
length(foo.list)
dim(foo.list) <- c(2, 2)
foo.list
class(foo.list)
class(foo.list[1,1])
```
By adding a dimension attribute, the list is coerced into a matrix of lists.

3. Look up the help page for `data.frame` and use the example code to create a small data frame containing numeric variables and factors.

```{r}
(foo.df <- data.frame(trt = letters[1:3], x = 1:3, y = rnorm(3)))
sapply(foo.df, class)
```

4. Use the `seq` function to generate a subscript vector that selects those elements of a vector that have even-numbered subscripts.

```{r}
(foo <- round(rnorm(10), 2))
(inds <- seq(2, 10, 2))
foo[inds]
```

5. Verify that vectors can have duplicated names and that if a subscript matches a duplicated name, only the first value is returned. What happens with `x[NA]`?

```{r}
foo <- 1:5
names(foo) <- c("A", "A", "A", "B", "C")
foo
foo["A"]
```
We do see that we can have duplicate names for vectors and that, when
subsetting by name, only the first is returned.

```{r}
foo[NA]
```

Subsetting with `NA` returns a vector of the same length as the
vector, but all names and values are missing.


6. Use logical subscripts to extract the even-numbered elements of the `letters` vector.

```{r}
letters[1:26 %% 2 == 0]
```

7. Let `x` be a vector of length 10 generated by `1:10` and suppose it has a dimension attribute so that it is a matrix with 2 columns and 5 rows. What is the matrix location of the 7th element of `x`? That is, which row and column is it in? Alternatively, which element of `x` is in the second row, first column?

```{r}
x <- 1:10
dim(x) <- c(5, 2)
x
```
When `R` coerces the vector into the $5 \times 2$ matrix, it creates
it by columns, i.e. the first column will contain the
first five values and the second column the last five.

Given this, the seventh element will be the second value in the second
column with coordinates $(2, 2)$.

8. What does `as.matrix()` do when applied to a data frame with columns of different types?

```{r}
foo.df
as.matrix(foo.df)
```

Because `character` is the most general class (i.e., all other classes
can be represented as a string), data.frames of mixed classes are
coerced such that all values are strings.

9. Fix each of the following common data frame subsetting errors:

```
mtcars[mtcars$cyl = 4, ]
mtcars[-1:4, ]
mtcars[mtcars$cyl <= 5]
mtcars[mtcars$cyl == 4 | 6, ]
```
Fixed:

```{r, eval = FALSE}
mtcars[mtcars$cyl == 4, ]
mtcars[-c(1:4), ]
mtcars[mtcars$cyl <= 5, ]
## mtcars[mtcars$cyl == 4 | mtcars$cyl == 6, ]
mtcars[mtcars$cyl != 8, ] ## more concise, since cyl = {4, 6, 8}
```

10. Consider the linear model: `mod <- lm(mpg ~ wt, data = mtcars)`. Describe the data structure of `mod`, including its componets. Extract the coefficients, residuals, and the residual degrees of freedom. Extract the R squared from the model summary, i.e., from `summary(mod)`.

```{r}
mod <- lm(mpg ~ wt, data = mtcars)
str(mod)
```
`mod` is a named list of twelve structures with class `lm`.  Each element of
`mod` contains some information about the model that was fit, such as
the model.matrix, residuals, coefficients, etc.

Because (S3) class objects in `R` are just lists with a class attribute,
the components in any class object can be extracted with the `$`
operator or by using the name in the double brackets.  Additionally,
`lm` is a generic class which supports acommon convention of
functions for extracting many of these  components with the function
name matching the component name.


```{r}
mod$coef
mod[["residuals"]]
df.residual(mod)
summary(mod)$r.sq
```

