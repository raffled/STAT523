---
title: 'Chapter 9: Debugging'
author: "jharner"
date: "July 19, 2015"
output: html_document
---

What happens when something goes wrong with your R code? What do you do? This chapter will:

* teach you how to fix unanticipated problems (debugging),  
* show you how functions can communicate problems and how you can take action based on those communications (condition handling),  
* teach you how to avoid common problems before they occur (defensive programming).  

Not all problems are unexpected. When writing a function, you can often anticipate potential problems (like a non-existent file or the wrong type of input). Communicating these problems to the user is the job of conditions: errors, warnings, and messages.

* Fatal errors are raised by `stop()` and force all execution to terminate. Errors are used when there is no way for a function to continue.  
* Warnings are generated by `warning()` and are used to display potential problems, such as when some elements of a vectorised input are invalid, like `log(-1:2)`.  
* Messages are generated by `message()` and are used to give informative output in a way that can easily be suppressed by the user (`?suppressMessages()`).

Conditions are usually displayed prominently, in a bold font or coloured red depending on your R interface. You can tell them apart because errors always start with “Error” and warnings with “Warning message”. Function authors can also communicate with their users with `print()` or `cat()`.

Condition handling tools, like `withCallingHandlers()`, `tryCatch()`, and `try()` allow you to take specific actions when a condition occurs. 

The chapter concludes with a discussion of “defensive” programming: ways to avoid common errors before they occur. The basic principle of defensive programming is to “fail fast”, to raise an error as soon as something goes wrong. In R, this takes three particular forms:

* checking that inputs are correct,  
* avoiding non-standard evaluation, and  
* avoiding functions that can return different types of output.  

## 9.1 Debugging techniques

Debugging code is challenging. While the procedure below is by no means foolproof, it will hopefully help you to organise your thoughts when debugging. There are four steps:

1. Realise that you have a bug  
2. Make it repeatable  
3. Figure out where it is  
4. Fix it and test it  

## 9.2 Debugging tools

 RStudio’s integrated debugging support makes life easier by exposing existing R tools in a user friendly way. There are three key debugging tools:

* RStudio’s error inspector and `traceback()` which list the sequence of calls that lead to the error.  
* RStudio’s “Rerun with Debug” tool and   `options(error = browser)`   which open an interactive session where the error occurred.  
* RStudio’s   breakpoints  and  `browser()`   which open an interactive session at an arbitrary location in the code.  

### 9.2.1 Determining the sequence of calls

The first tool is the call stack, the sequence of calls that lead up to an error. Here’s a simple example: you can see that `f()` calls `g()` calls `h()` calls `i()` which adds together a number and a string creating a error:
```
f <- function(a) g(a)
g <- function(b) h(b)
h <- function(c) i(c)
i <- function(d) {
  a <- 2
  "a" + d
}
f(10)
```
Two options appear to the right of the error message: “Show Traceback” and “Rerun with Debug”. If you’re not using Rstudio, you can use `traceback()` to get the same information:
```
traceback()
```

Sometimes this is enough information to let you track down the error and fix it. However, it’s usually not. `traceback()` shows you where the error occurred, but not why.

### 9.2.2 Browsing on error

The easiest way to enter the interactive debugger is through RStudio’s “Rerun with Debug” tool. This reruns the command that created the error, pausing execution where the error occurred. You’re now in an interactive state inside the function, and you can interact with any object defined there. You can:

* see the corresponding code in the editor (with the statement that will be run next highlighted),
* view objects in the current environment in the “Environment” pane,
* see the call stack in a “Traceback” pane, and
* run arbitrary R code in the console.

In debug mode you can access them either with the Rstudio toolbar or with the keyboard:

* Next, `n`: executes the next step in the function. Be careful if you have a variable named `n`; to print it you’ll need to do `print(n)`.
* Step into,  or `s`: works like next, but if the next step is a function, it will step into that function so you can work through each line.
* Finish, `f`: finishes execution of the current loop or function.
* Continue, `c`: leaves interactive debugging and continues regular execution of the function. This is useful if you’ve fixed the bad state and want to check that the function proceeds correctly.
* Stop, `Q`: stops debugging, terminates the function, and returns to the global workspace. Use this once you’ve figured out where the problem is, and you’re ready to fix it and reload the code.

There are two other slightly less useful commands that aren’t available in the toolbar:
* Enter: repeats the previous command. I find this too easy to activate accidentally, so I turn it off using `options(browserNLdisabled = TRUE)`.
* `where`: prints stack trace of active calls (the interactive equivalent of `traceback`).

To enter this style of debugging outside of RStudio, you can use the error option which specifies a function to run when an error occurs. The function most similar to Rstudio’s debug is `browser()`: this will start an interactive console in the environment where the error occurred. Use `options(error = browser)` to turn it on, re-run the previous command, then use `options(error = NULL)` to return to the default error behaviour. You could automate this with the `browseOnce()` function as defined below:
```
browseOnce <- function() {
  old <- getOption("error")
  function() {
    options(error = old)
    browser()
  }
}
options(error = browseOnce())

f <- function() stop("!")
f()
f()

options(error = NULL)

# or
options(error = browser)
```

There are two other useful functions that you can use with the error option:

* `recover` is a step up from browser, as it allows you to enter the environment of any of the calls in the call stack. This is useful because often the root cause of the error is a number of calls back.
* `dump.frames` is an equivalent to `recover` for non-interactive code. It creates a `last.dump.rda` file in the current working directory. Then, in a later interactive R session, you load that file, and use `debugger()` to enter an interactive debugger with the same interface as `recover()`. This allows interactive debugging of batch code.

```
# In batch R process ----
dump_and_quit <- function() {
  # Save debugging info to file last.dump.rda
  dump.frames(to.file = TRUE)
  # Quit R with error status
  q(status = 1)
}
options(error = dump_and_quit)

# In a later interactive session ----
load("last.dump.rda")
debugger()

options(error = NULL)
```

### 9.2.3 Browsing arbitrary code

As well as entering an interactive console on error, you can enter it at an arbitrary code location by using either an Rstudio `breakpoint` or `browser()`. You can set a breakpoint in Rstudio by clicking to the left of the line number, or pressing Shift + F9. Equivalently, add `browser()` where you want execution to pause. Breakpoints behave similarly to `browser()` but they are easier to set (one click instead of nine key presses), and you don’t run the risk of accidentally including a `browser()` statement in your source code. There are two small downsides to breakpoints:

* There are a few unusual situations in which breakpoints will not work: read breakpoint troubleshooting for more details.  
* RStudio currently does not support conditional breakpoints, whereas you can always put `browser()` inside an if statement.  

As well as adding `browser()` yourself, there are two other functions that will add it to code:

* `debug()` inserts a browser statement in the first line of the specified function. `undebug()` removes it. Alternatively, you can use `debugonce()` to browse only on the next run.
* `utils::setBreakpoint()` works similarly, but instead of taking a function name, it takes a file name and line number and finds the appropriate function for you.

These two functions are both special cases of `trace()`, which inserts arbitrary code at any position in an existing function. `trace()` is occasionally useful when you’re debugging code that you don’t have the source for. To remove tracing from a function, use `untrace()`. You can only perform one trace per function, but that one trace can call multiple functions.

### 9.2.4 The call stack: `traceback()`, `where`, and `recover()`

Unfortunately the call stacks printed by `traceback()`, `browser()` + `where`, and `recover()` are not consistent. The following table shows how the call stacks from a simple nested set of calls are displayed by the three tools.

See the text.

### 9.2.5 Other types of failure

There are other ways for a function to fail apart from throwing an error or returning an incorrect result.

* A function may generate an unexpected warning. The easiest way to track down warnings is to convert them into errors with `options(warn = 2)` and use the regular debugging tools. When you do this you’ll see some extra calls in the call stack, like `doWithOneRestart()`, `withOneRestart()`, `withRestarts()`, and `.signalSimpleWarning()`. Ignore these: they are internal functions used to turn warnings into errors.  
* A function may generate an unexpected message. There’s no built-in tool to help solve this problem, but it’s possible to create one:  

```
message2error <- function(code) {
  withCallingHandlers(code, message = function(e) stop(e))
}

f <- function() g()
g <- function() message("Hi!")
g()

message2error(g())
traceback()
```

## 9.3 Condition handling

Unexpected errors require interactive debugging to figure out what went wrong. Some errors, however, are expected, and you want to handle them automatically. In R, expected errors crop up most frequently when you’re fitting many models to different datasets, such as bootstrap replicates. Sometimes the model might fail to fit and throw an error, but you don’t want to stop everything. Instead, you want to fit as many models as possible and then perform diagnostics after the fact.

In R, there are three tools for handling conditions (including errors) programmatically:

* `try()` gives you the ability to continue execution even when an error occurs.
* `tryCatch()` lets you specify handler functions that control what happens when a condition is signalled.
* `withCallingHandlers()` is a variant of `tryCatch()` that runs its handlers in a different context. It’s rarely needed, but is useful to be aware of.

### 9.3.1 Ignore errors with `try`

`try()` allows execution to continue even after an error has occurred. For example, normally if you run a function that throws an error, it terminates immediately and doesn’t return a value:  

```
f1 <- function(x) {
  log(x)
  10
}
f1("x")
```

However, if you wrap the statement that creates the error in try(), the error message will be printed but execution will continue:  

```{r}
f2 <- function(x) {
  try(log(x))
  10
}
f2("a")
```

To pass larger blocks of code to try(), wrap them in {}:  

```{r}
try({
  a <- 1
  b <- "x"
  a + b
})
```

You can also capture the output of the `try()` function. If successful, it will be the last result evaluated in the block (just like a function). If unsuccessful it will be an (invisible) object of class “try-error”:
```{r}
success <- try(1 + 2)
failure <- try("a" + "b")
class(success)
class(failure)
```

`try()` is particularly useful when you’re applying a function to multiple elements in a list:
```{r}
elements <- list(1:10, c(-1, 10), c(T, F), letters)
# results <- lapply(elements, log)
results <- lapply(elements, function(x) try(log(x)))
```

### 9.3.2 Handle conditions with `tryCatch()`

`tryCatch()` is a general tool for handling conditions: in addition to errors, you can take different actions for warnings, messages, and interrupts. You’ve seen errors (made by `stop()`), warnings (`warning()`) and messages (`message()`) before, but interrupts are new. They can’t be generated directly by the programmer, but are raised when the user attempts to terminate execution by pressing Ctrl + Break, Escape, or Ctrl + C (depending on the platform).

With `tryCatch()` you map conditions to handlers, named functions that are called with the condition as an input. If a condition is signalled, `tryCatch()` will call the first handler whose name matches one of the classes of the condition. The only useful built-in names are `error`, `warning`, `message`, `interrupt`, and the `catch-all` condition. A handler function can do anything, but typically it will either return a value or create a more informative error message. For example, the `show_condition()` function below sets up handlers that return the type of condition signalled:
```{r}
show_condition <- function(code) {
  tryCatch(code,
    error = function(c) "error",
    warning = function(c) "warning",
    message = function(c) "message"
  )
}
show_condition(stop("!"))
show_condition(warning("?!"))
show_condition(message("?"))
show_condition(10)
```

### 9.3.3 `withCallingHandlers`

An alternative to `tryCatch()` is `withCallingHandlers()`. There are two main differences between these functions:

* The return value of `tryCatch()` handlers is returned by `tryCatch()`, whereas the return value of `withCallingHandlers()` handlers is ignored.  
* The handlers in `withCallingHandlers()` are called in the context of the call that generated the condition whereas the handlers in `tryCatch()` are called in the context of `tryCatch()`. This is shown here with `sys.calls()`, which is the run-time equivalent of `traceback()` — it lists all calls leading to the current function.  

### 9.3.4 Custom signal classes

One of the challenges of error handling in R is that most functions just call `stop()` with a string. That means if you want to figure out if a particular error occurred, you have to look at the text of the error message. This is error prone, not only because the text of the error might change over time, but also because many error messages are translated, so the message might be completely different to what you expect.

R has a little known and little used feature to solve this problem. Conditions are S3 classes, so you can define your own classes if you want to distinguish different types of error. Each condition signalling function, `stop()`, `warning()`, and `message()`, can be given either a list of strings, or a custom S3 condition object. Custom condition objects are not used very often, but are very useful because they make it possible for the user to respond to different errors in different ways. For example, “expected” errors (like a model failing to converge for some input datasets) can be silently ignored, while unexpected errors (like no disk space available) can be propagated to the user.

## 9.4 Defensive programming

Defensive programming is the art of making code fail in a well-defined manner even when something unexpected occurs. A key principle of defensive programming is to “fail fast”: as soon as something wrong is discovered, signal an error. 

In R, the “fail fast” principle is implemented in three ways:

* Be strict about what you accept. For example, if your function is not vectorised in its inputs, but uses functions that are, make sure to check that the inputs are scalars. You can use stopifnot(), the assertthat package, or simple if statements and `stop()`.  
* Avoid functions that use non-standard evaluation, like subset, transform, and with. These functions save time when used interactively, but because they make assumptions to reduce typing, when they fail, they often fail with uninformative error messages. You can learn more about non-standard evaluation in non-standard evaluation.  
* Avoid functions that return different types of output depending on their input. The two biggest offenders are `[` and `sapply()`. Whenever subsetting a data frame in a function, you should always use `drop = FALSE`, otherwise you will accidentally convert 1-column data frames into vectors. Similarly, never use `sapply()` inside a function: always use the stricter `vapply()` which will throw an error if the inputs are incorrect types and return the correct type of output even for zero-length inputs.  










